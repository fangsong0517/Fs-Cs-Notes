# 数组与矩阵

## 1. 把数组中的 0 移到末尾

283. Move Zeroes (Easy)

[Leetcode (opens new window)](https://leetcode.com/problems/move-zeroes/description/)/ [力扣(opens new window)](https://leetcode-cn.com/problems/move-zeroes/description/)

```html
For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].
```

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
       int j = 0;
       int n = nums.size();
       for(int i = 0; i < nums.size(); i++) {
           if(nums[i] != 0) {
               nums[j++] = nums[i];
           }
       } 
       while(j < nums.size()) {
           nums[j++] = 0;
       }
    }
};
```

## 2. 改变矩阵维度

566. Reshape the Matrix (Easy)

[Leetcode (opens new window)](https://leetcode.com/problems/reshape-the-matrix/description/)/ [力扣](https://leetcode-cn.com/problems/reshape-the-matrix/description/)

```html
Input:
nums =
[[1,2],
 [3,4]]
r = 1, c = 4

Output:
[[1,2,3,4]]

Explanation:
The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.
```

```cpp
class Solution {
public:
    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {
        int t = 0;
        int l = 0;
        if((r * c) > (nums.size() * nums[0].size()) || (r * c) < (nums.size() * nums[0].size())) {
            r = nums.size();
            c = nums[0].size();
        }
        vector<vector<int>>resh(r, vector<int>(c, 0));
        for(int i = 0; i < nums.size(); i++) {
            for(int j = 0; j < nums[0].size(); j++) {
                if(l < c) {
                    resh[t][l++] = nums[i][j];
                } else {
                    t++;
                    l = 0;
                    resh[t][l++] = nums[i][j];
                }
            }
        }
        return resh;
    }
};
```

## 3. 找出数组中最长的连续 1

485. Max Consecutive Ones (Easy)

[Leetcode (opens new window)](https://leetcode.com/problems/max-consecutive-ones/description/)/ [力扣](https://leetcode-cn.com/problems/max-consecutive-ones/description/)

```cpp
class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& nums) {
        int mmax = 0, cur = 0;
        for(auto x : nums) {
            cur = x == 0 ? 0 : cur + 1;
            mmax = max(cur, mmax);
        }
        return mmax;
    }
};
```

## 4. 有序矩阵查找

240. Search a 2D Matrix II (Medium)

[Leetcode (opens new window)](https://leetcode.com/problems/search-a-2d-matrix-ii/description/)/ [力扣](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/description/)

```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int n = matrix.size();
        int m = matrix[0].size();
        int i = n - 1, j = 0;
        while(i >= 0 && j < m) {
            if(matrix[i][j] > target) {
                i--;
            } else if(matrix[i][j] < target) {
                j++;
            } else if(matrix[i][j] == target){
                return true;
            }
        }
        return false;
    }
};
```

## 5. 有序矩阵的 Kth Element

378. Kth Smallest Element in a Sorted Matrix ((Medium))

[Leetcode (opens new window)](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/)/ [力扣(opens new window)](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/description/)

```cpp
class Solution {
public:
    int check(vector<vector<int>>&matrix, int x, int n, int m) {
        int cnt = 0, j = n;
        for(int i = 0; i < m; i++) {
            while(j && matrix[j - 1][i] > x) {j--;}
            cnt += j;
        }
        return cnt;
    }
    int kthSmallest(vector<vector<int>>& matrix, int k) {
        int n = matrix.size(), m = matrix[0].size();
        int l = matrix[0][0], r = matrix[n - 1][m - 1];
        while(l < r) {
            int mid = (l + r) >> 1;
            int ret = check(matrix, mid, n, m);
            if(ret < k) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        return l;
    }
};
```

## 6. 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数

645. Set Mismatch (Easy)

[Leetcode (opens new window)](https://leetcode.com/problems/set-mismatch/description/)/ [力扣(opens new window)](https://leetcode-cn.com/problems/set-mismatch/description/)

```html
Input: nums = [1,2,2,4]
Output: [2,3]
Input: nums = [1,2,2,4]
Output: [2,3]
```

```cpp
class Solution {
public:
    vector<int> findErrorNums(vector<int>& nums) {
        vector<int>f(nums.size() + 1, 0);
        for(int i = 0; i < nums.size(); i++) {
            f[nums[i]]++;
        }
        int l = 0, r = 0;
        for(int i = 1; i <= nums.size(); i++) {
            if(f[i] == 0) {
                r = i;
            }
            if(f[i] == 2) {
                l = i;
            }
        }
        return {l, r};
    }
};
```

