# 单调栈

## 1. [5614. 找出最具竞争力的子序列](https://leetcode-cn.com/problems/find-the-most-competitive-subsequence/)

```html
示例 1：

输入：nums = [3,5,2,6], k = 2
输出：[2,6]
解释：在所有可能的子序列集合 {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 最具竞争力。
示例 2：

输入：nums = [2,4,3,3,5,4,9,6], k = 4
输出：[2,3,3,4]
```

思路：

维护一个单调栈，从左到右遍历数组。

1. 如果当前元素比队尾元素小，下来判断剩余数组长度（len - i）和目标栈还需要元素个数（k - stack.size() + 1）大小。
   1.1 如果前者小于或等于后者，则说明不能再出栈了，否则剩余数组全加进栈也不够将栈填到k+1长度。（需要k+1而不是k是因为一开始就填进了-1，但这个-1是不会被返回的）
   1.2 如果前者大于后者，就将队尾元素出栈，并重复第一步

2. 如果栈长度不够，不用判断，直接将当前元素进栈即可。

```cpp
class Solution {
public:
    vector<int> mostCompetitive(vector<int>& nums, int k) {
        if(nums.size() == k) return nums;
        int n = nums.size();
        vector<int>ans;
        for(int i = 0; i < n; i++) {
            while(ans.size() > 0 && ans.back() > nums[i] && n - i >= k - ans.size() + 1) {
                ans.pop_back();
            }
            if(ans.size() < k) ans.push_back(nums[i]);
        }
        return ans;
    }
};
```

## 2. [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

![img](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/rainwatertrap.png)

 ```html
示例:
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
 ```

```cpp
class Solution {
public:
    int trap(vector<int>& h) {
        if(h.empty()) return 0;
        int s = 0, top, distance, height;
        stack<int>stk;
        for(int i = 0; i < h.size(); i++) {
            while(!stk.empty() && h[i] > h[stk.top()]) {//当前墙高于左边的，违反递减
            //需要把中间的高度比我小的处理掉，保持栈内单调递减。
                top = stk.top();//左边的墙 墙的位置记为top（待处理的）
                stk.pop();//删除之（处理掉）
                if(stk.empty())break;//top他没有左边墙了
                distance = i - stk.top() - 1;//还有左边墙
                height = min(h[i], h[stk.top()]) - h[top];
                //两边的最低的高度（水高） - 自身高度（容器厚度）
                s += distance * height;
            }//处理完了，此时容器是递减 的了， 或者为空
            stk.push(i);//递减的话会一直push进来（一个\斜坡，存不住水）
            //一旦不是斜坡了，就会进入上面的while循环
        }
        return s;
    }
};
```

## 3. 255. 验证前序遍历序列二叉搜索树

给定一个整数数组，你需要验证它是否是一个**二叉搜索树**正确的**先序**遍历序列。

你可以假定该序列中的数都是不相同的。

```html
参考以下这颗二叉搜索树：

     5
    / \
   2   6
  / \
 1   3
示例 1：
输入: [5,2,6,1,3]
输出: false

示例 2：
输入: [5,2,1,3,6]
输出: true

进阶挑战：
您能否使用恒定的空间复杂度来完成此题？
```

![在这里插入图片描述](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/20200707232044116.png)

```cpp
class Solution {
	map<int,int> m;
public:
    bool verifyPreorder(vector<int>& preorder) {
    	if(preorder.size() <= 2) return true;
    	int MIN = INT_MIN;
    	stack<int> s;
    	for(int i = 0; i < preorder.size(); ++i)
    	{
    		if(preorder[i] < MIN)
    			return false;
    		while(!s.empty() && s.top() < preorder[i])//遇到大的了，右分支
    		{
    			MIN = s.top();//记录弹栈的栈顶为最小值
    			s.pop();
    		}
    		s.push(preorder[i]);
    	}
    	return true;
    }
};
```

## 4. [316. 去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)

给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的**字典序最小**（要求不能打乱其他字符的相对位置）。

```html
示例 1：
输入：s = "bcabc"
输出："abc"

示例 2：
输入：s = "cbacdcbc"
输出："acdb"
 
提示：
1 <= s.length <= 10^4
s 由小写英文字母组成
```

- 记录每个字符最后出现的位置
- 一旦前面的字符比当前的大，且在后面还存在该大字符，则删除该大的字符

```cpp
class Solution {
public:
    string removeDuplicateLetters(string s) {
        vector<int>last(26, -1);
        for(int i = 0; i < s.size(); i++) {
            last[s[i] - 'a'] = i;//记录字符出现的最后的位置
        }
        string str;
        unordered_set<char>set;//记录字符是否写入答案了
        for(int i = 0; i < s.size(); i++) {
            if(set.count(s[i]))continue;//已经写入
            while(!str.empty() && str.back() > s[i] && last[str.back() - 'a'] > i) {//出现比栈顶元素小的值，最后出现的为准, 一旦前面的字符比当前的大，且在后面还存在该大字符，则删除该大的字符

                set.erase(str.back());
                str.pop_back();
            }
            set.insert(s[i]);//入
            str += s[i];
        }
        return str;
    }
};
```

