递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。

# 斐波那契数列

## [1. 爬楼梯]()

70. Climbing Stairs (Easy)

[Leetcode](https://leetcode.com/problems/climbing-stairs/description/) / [力扣](https://leetcode-cn.com/problems/climbing-stairs/description/)

题目描述：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。

定义一个数组 dp 存储上楼梯的方法数（为了方便讨论，数组下标从 1 开始），dp[i] 表示走到第 i 个楼梯的方法数目。

第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。

![img](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/14fe1e71-8518-458f-a220-116003061a83.png)



考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 空间复杂度优化为 O(1) 复杂度。

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if(n == 1 || n == 0) return n;
        vector<int>f(n + 1, 0);
        f[1] = 1;
        f[2] = 2;
        for(int i = 3; i <= n; i++) {
            f[i] = f[i - 1] + f[i - 2];
        }
        return f[n];
    }
};
```

## [2. 强盗抢劫]()

198. House Robber (Easy)

[Leetcode](https://leetcode.com/problems/house-robber/description/) / [力扣](https://leetcode-cn.com/problems/house-robber/description/)

题目描述：抢劫一排住户，但是不能抢邻近的住户，求最大抢劫量。

定义 dp 数组用来存储最大的抢劫量，**其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量**。

由于不能抢劫邻近住户，**如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户**，所以

![img](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/2de794ca-aa7b-48f3-a556-a0e2708cb976.jpg)

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        vector<int>dp(nums.size(), 0);
        if(nums.size() == 1) return nums[0];
        if(nums.size() == 2) return max(nums[0], nums[1]);
        if(nums.size() == 0)return 0;
        dp[0] = nums[0];
        dp[1] = max(nums[1], nums[0]);
        for(int i = 2; i < nums.size(); i++) {
            dp[i] = max(dp[i - 2] + nums[i] , dp[i - 1]);
        }
        return dp[nums.size() - 1];
    }
};

```

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int pre2 = 0, pre1 = 0;
        for(int i = 0; i < nums.size(); i++) {
            int cur = max(pre2 + nums[i], pre1);
            pre2 = pre1;
            pre1 = cur;
        }
        return pre1;
    }
};
```

## 3. 强盗在环形街区抢劫

213. House Robber II (Medium)

[Leetcode](https://leetcode.com/problems/house-robber-ii/description/) / [力扣](https://leetcode-cn.com/problems/house-robber-ii/description/)

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        int n = nums.size();
        if(n==1) return nums[0];
        return max(func(nums, 0, n - 2),func(nums, 1, n - 1));
    }
    int func(vector<int>& nums, int l, int r) {
        int pre2 = 0, pre1 = 0;
        for(int i = l; i <= r; i++) {
            int cur = max(pre2 + nums[i], pre1);
            pre2 = pre1;
            pre1 = cur;
        }
        return pre1;
    }
};
```

## [4. 信件错排]()

题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量。

定义一个数组 dp 存储错误方式数量，**dp[i] 表示前 i 个信和信封的错误方式数量**。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：

- i==k，交换 i 和 j 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式。
- i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式。

综上所述，错误装信数量方式数量为：

![img](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/da1f96b9-fd4d-44ca-8925-fb14c5733388.png)



定义一个数组dp[]存储错误方式数量。dp[i]表示，有i封信、i个信箱情况下的错误装信方法总数。

对于第N封信而言，假设其装在了第 K 个信箱中，对于第 K 封信，有两种情况，

（1）信件 K 装在信箱 N 中；（2）信件 K 未被装在信箱 N 中。

**1. 信件K装在信箱N中**

如下图所示：
![技术图片](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/20200703mail1.png)
我们不看 K 和 N 两对信件和信箱，只关注剩下 N-2 对信件和信箱，有 dp[N-2] 种错误装信方法。同时， K 的取值范围： 1~N-1 ，因此共有 (N-1)*dp[N-2] 种错误装信方法。

**2. 信件 K 未被装在信箱 N 中**

如下图所示：
![技术图片](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/20200703mail2.png)

先给出结果，该情况的错误装信方法有 (N-1)*dp[N-1] 种。这个 dp[N-1] 是如何得出来，我思考了良久。

我们把问题重新描述一下，思路就会清晰很多。事实上，对于信件 i 来说，信箱 i 是它的“专属信箱”，每个信件都不能放入自己的专属信箱，对于n 个信件而言，都需要找其它 n-1 个信箱放入，其错排方法数为 dp[n] 。

问题的症结在于，对于上图中的信件 K 来说，其专属信箱，即 K 信箱已经被占用。

但是，我们可以把信箱 N 当做信件 K 的“专属信箱”，因为本情况下，信件 K 也不能放入信箱 N 。所以可以理解成求 N-1 封信件和 N-1 个信箱（除去信件 N）之间的错排数量问题。所以得到 dp[N-1]。

同理 K 的取值范围： 1~N-1 ，因此共有 (N-1)*dp[N-1] 种错误装信方法。

## 5. 母牛生产

题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。

第 i 年成熟的牛的数量为：

![img](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/879814ee-48b5-4bcb-86f5-dcc400cb81ad.png)

# 矩阵路径

## 1. 矩阵的最小路径和

64. Minimum Path Sum (Medium)

    [Leetcode](https://leetcode.com/problems/minimum-path-sum/description/) / [力扣](https://leetcode-cn.com/problems/minimum-path-sum/description/)

    ```html
    [[1,3,1],
     [1,5,1],
     [4,2,1]]
    Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum.Copy to clipboardErrorCopied
    ```

    题目描述：求从矩阵的左上角到右下角的最小路径和，每次只能向右和向下移动。

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        vector<vector<int>>dp(n, vector<int>(m, 0));
        for(int i = 0; i < n; i ++) {
            for(int j = 0; j < m; j++) {
                if(i == 0 && j!= 0) {
                    dp[i][j] = dp[i][j - 1] + grid[i][j];
                } else if(i != 0 && j == 0) {
                    dp[i][j] = dp[i - 1][j] + grid[i][j];
                } else if(i == 0 && j == 0) {
                    dp[i][j] = grid[i][j];
                } else {
                    dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];
                }
            }
        }
        return dp[n - 1][m - 1];
    }
};
```

## [2. 矩阵的总路径数]()

62. Unique Paths (Medium)

[Leetcode](https://leetcode.com/problems/unique-paths/description/) / [力扣](https://leetcode-cn.com/problems/unique-paths/description/)

题目描述：统计从矩阵左上角到右下角的路径总数，每次只能向右或者向下移动。

![img](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/dc82f0f3-c1d4-4ac8-90ac-d5b32a9bd75a.jpg)

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>>f(n, vector<int>(m, 1));
        for(int i = 1; i < n; i++) {
            for(int j = 1; j < m; j++) {
                f[i][j] = f[i - 1][j] + f[i][j - 1];
            }
        }
        return f[n - 1][m - 1];
    }
};
```

# 数组区间

## 1. 数组区间和

303. Range Sum Query - Immutable (Easy)

[Leetcode](https://leetcode.com/problems/range-sum-query-immutable/description/) / [力扣](https://leetcode-cn.com/problems/range-sum-query-immutable/description/)

```html
Given nums = [-2, 0, 3, -5, 2, -1]

sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3Copy to clipboardErrorCopied
```

求区间 i ~ j 的和，可以转换为 sum[j + 1] - sum[i]，其中 sum[i] 为 0 ~ i - 1 的和

```cpp
class NumArray {
public:
    vector<int>S;
    NumArray(vector<int>& nums) {
        int n = nums.size();
        S.resize(n + 1, 0);
        for(int i = 1; i <= nums.size(); i++) {
            S[i] = S[i - 1] + nums[i - 1];
        }
    }
    
    int sumRange(int i, int j) {
        return S[j + 1] - S[i];
    }
};

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray* obj = new NumArray(nums);
 * int param_1 = obj->sumRange(i,j);
 */
```

## 2. 数组中等差递增子区间的个数

413. Arithmetic Slices (Medium)

[Leetcode](https://leetcode.com/problems/arithmetic-slices/description/) / [力扣](https://leetcode-cn.com/problems/arithmetic-slices/description/)

```html
A = [0, 1, 2, 3, 4]

return: 6, for 3 arithmetic slices in A:

[0, 1, 2],
[1, 2, 3],
[0, 1, 2, 3],
[0, 1, 2, 3, 4],
[1, 2, 3, 4],
[2, 3, 4]
```

dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数。

当 A[i] - A[i-1] == A[i-1] - A[i-2]，那么 [A[i-2], A[i-1], A[i]] 构成一个等差递增子区间。而且在以 A[i-1] 为结尾的递增子区间的后面再加上一个 A[i]，一样可以构成新的递增子区间。

```html
dp[2] = 1
    [0, 1, 2]
dp[3] = dp[2] + 1 = 2
    [0, 1, 2, 3], // [0, 1, 2] 之后加一个 3
    [1, 2, 3]     // 新的递增子区间
dp[4] = dp[3] + 1 = 3
    [0, 1, 2, 3, 4], // [0, 1, 2, 3] 之后加一个 4
    [1, 2, 3, 4],    // [1, 2, 3] 之后加一个 4
    [2, 3, 4]        // 新的递增子区间
```

综上，在 A[i] - A[i-1] == A[i-1] - A[i-2] 时，dp[i] = dp[i-1] + 1。

因为递增子区间不一定以最后一个元素为结尾，可以是任意一个元素结尾，因此需要返回 dp 数组累加的结果。

```cpp
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& A) {
        if(A.size() == 0) return 0;
        int n = A.size();
        vector<int>dp(n + 1, 0);
        for(int i = 2; i < n; i++) {
            if(A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {
                dp[i] = dp[i - 1] + 1;
            }
        }
        int t = 0;
        for(int i = 0; i < dp.size(); i++) {
            t += dp[i];
        }
        return t;
    }
};
```

# 分割整数

## 1. 分割整数的最大乘积

343. Integer Break (Medim)

[Leetcode](https://leetcode.com/problems/integer-break/description/) / [力扣](https://leetcode-cn.com/problems/integer-break/description/)

题目描述：For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).

![image-20201111232728333](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20201111232728333.png)

```cpp
class Solution {
public:
    int integerBreak(int n) {
        vector<int>dp(n + 1, 0);
        dp[1] = 1;
        for(int i = 2; i <= n; i++) {
            for(int j = 1; j <= i - 1; j++) {
                dp[i] = max(dp[i], max(j * dp[i - j], j * (i - j)));
            }
        }
        return dp[n];
    }
};
```



**方法二：**

> 以下数学推导总体分为两步：① 当所有拆分出的数字相等时，乘积最大。② 最优拆分数字为 3 。

![image-20201111233143171](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20201111233143171.png)

![image-20201111233200246](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20201111233200246.png)

![Picture2.png](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/1d32896766463a7a74ffafe47e7f57008e563b8fe7a8e4d52525732ac8d34275-Picture2.png)



```cpp
//尽可能多分出几个3
class Solution {
public:
    int integerBreak(int n) {
        if(n == 2) return 1;
        if(n == 3) return 2;
        int a = 1;
        while(n > 4) {
            n = n - 3;
            a = a * 3;
        }
        return a * n;
    }
};
```

## 2. 按平方数来分割整数

279. Perfect Squares(Medium)

[Leetcode](https://leetcode.com/problems/perfect-squares/description/) / [力扣](https://leetcode-cn.com/problems/perfect-squares/description/)

题目描述：For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.

![image-20201112212546173](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20201112212546173.png)

![image-20201112211707966](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20201112211707966.png)

```cpp
//f[i]是组成i的个数
class Solution {
public:
    int numSquares(int n) {
        vector<int>f(n + 1, 0);
        for(int i = 1; i <= n; i++) {
            int mmin = INT_MAX;
            for(int j = 1; j * j <= i; j++) {
                mmin = min(mmin, f[i - j * j]);
            }
            f[i] = mmin + 1;
        }
        return f[n];
    }
};
```

## [3. 分割整数构成字母字符串](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode 题解 - 动态规划?id=_3-分割整数构成字母字符串)

91. Decode Ways (Medium)

[Leetcode](https://leetcode.com/problems/decode-ways/description/) / [力扣](https://leetcode-cn.com/problems/decode-ways/description/)

题目描述：Given encoded message "12", it could be decoded as "AB" (1 2) or "L" (12).

定义：dp[i]：从索引0到i的字符串s的子串所能够解码的总数。



斐波那契的公式为：F(n) = F(n - 1) + F(n - 2)。

用count(str)来表示字符串str的解码个数，那么有：

count(str) = count(str.substring(0, length - 2)) + count(str.substring(0, length - 1))

具体的例子如："12321"的解码数 = "1232"的解码数 + "123"的解码数，当然也要考虑后1、2位能否构成合法的字母。

```cpp
class Solution {
public:
    int numDecodings(string s) {
        if(s[0] == '0') return 0;
        vector<int>dp(s.size() + 1);
        dp[0] = dp[1] = 1;
        for(int i = 2; i <= s.length(); i++) {
             //如果该位不为'0'， 说明该位单独成字母合法
            if(s[i - 1] != '0') {
                dp[i] += dp[i - 1];
            }
             //如果后两位能组成"1x"（x为任意数字）或者"2x"（x小于7），说明最后两位组成字母合法
            if((s[i - 2] == '1') || (s[i - 2] == '2' && s[i - 1] <= '6')) {
                dp[i] += dp[i - 2];
            }
        }
        return dp[s.length()]; 
    }
};
```

# 最长递增子序列

已知一个序列 {S<sub>1</sub>, S<sub>2</sub>,...,S<sub>n</sub>}，取出若干数组成新的序列 {S<sub>i1</sub>, S<sub>i2</sub>,..., S<sub>im</sub>}，其中 i1、i2 ... im 保持递增，即新序列中各个数仍然保持原数列中的先后顺序，称新序列为原序列的一个  **子序列**  。

如果在子序列中，当下标 ix > iy 时，S<sub>ix</sub> > S<sub>iy</sub>，称子序列为原序列的一个  **递增子序列**  。

定义一个数组 dp 存储最长递增子序列的长度，dp[n] 表示以 S<sub>n</sub> 结尾的序列的最长递增子序列长度。对于一个递增子序列 {S<sub>i1</sub>, S<sub>i2</sub>,...,S<sub>im</sub>}，如果 im < n 并且 S<sub>im</sub> < S<sub>n</sub>，此时 {S<sub>i1</sub>, S<sub>i2</sub>,..., S<sub>im</sub>, S<sub>n</sub>} 为一个递增子序列，递增子序列的长度增加 1。满足上述条件的递增子序列中，长度最长的那个递增子序列就是要找的，在长度最长的递增子序列上加上 S<sub>n</sub> 就构成了以 S<sub>n</sub> 为结尾的最长递增子序列。因此 dp[n] = max{ dp[i]+1 | S<sub>i</sub> < S<sub>n</sub> && i < n} 。

因为在求 dp[n] 时可能无法找到一个满足条件的递增子序列，此时 {S<sub>n</sub>} 就构成了递增子序列，需要对前面的求解方程做修改，令 dp[n] 最小为 1，即：

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ee994da4-0fc7-443d-ac56-c08caf00a204.jpg" width="350px"> </div><br>

对于一个长度为 N 的序列，最长递增子序列并不一定会以 S<sub>N</sub> 为结尾，因此 dp[N] 不是序列的最长递增子序列的长度，需要遍历 dp 数组找出最大值才是所要的结果，max{ dp[i] | 1 <= i <= N} 即为所求。

## 1. 最长递增子序列

300\. Longest Increasing Subsequence (Medium)

[Leetcode](https://leetcode.com/problems/longest-increasing-subsequence/description/) / [力扣](https://leetcode-cn.com/problems/longest-increasing-subsequence/description/)

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        vector<int>f(n, 1);
        for(int i = 1; i < n; i++) {
            for(int j = 0; j < i; j++) {
                if(nums[i] > nums[j])f[i] = max(f[i], f[j] + 1);
            }
        }
        int mmax = 0;
        for(int i = 0; i < n; i++) {
            mmax = max(mmax, f[i]);
        }
        return mmax;
    }
};
```

## 2. 一组整数对能够构成的最长链

646\. Maximum Length of Pair Chain (Medium)

[Leetcode](https://leetcode.com/problems/maximum-length-of-pair-chain/description/) / [力扣](https://leetcode-cn.com/problems/maximum-length-of-pair-chain/description/)

```html
Input: [[1,2], [2,3], [3,4]]
Output: 2
Explanation: The longest chain is [1,2] -> [3,4]
```

题目描述：对于 (a, b) 和 (c, d) ，如果 b < c，则它们可以构成一条链。

```cpp
class Solution {
public:
    int findLongestChain(vector<vector<int>>& pairs) {
        if(pairs.size() == 0) return 0;
        sort(pairs.begin(), pairs.end(), [](auto a, auto b) {
            return a[0] < b[0];
        });
        int n = pairs.size();
        vector<int>dp(n, 1);
        for(int i = 1; i < n; i++) {
            for(int j = 0; j < i; j++) {
                if(pairs[j][1] < pairs[i][0]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
        }
        int mmax = 0;
        for(int i = 0; i < n; i++) {
            mmax = max(mmax, dp[i]);
        }
        return mmax;
    }
};
```

## 3. 最长摆动子序列

376\. Wiggle Subsequence (Medium)

[Leetcode](https://leetcode.com/problems/wiggle-subsequence/description/) / [力扣](https://leetcode-cn.com/problems/wiggle-subsequence/description/)

```html
Input: [1,7,4,9,2,5]
Output: 6
The entire sequence is a wiggle sequence.

Input: [1,17,5,10,13,15,10,5,16,8]
Output: 7
There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].

Input: [1,2,3,4,5,6,7,8,9]
Output: 2
```

因为是交替的，所以从头到尾都在记录着   

```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        int up = 1, down = 1;
        for(int i = 1; i < nums.size(); i++) {
            if(nums[i] > nums[i - 1]) {
                up = down + 1;
            } else if(nums[i] < nums[i - 1]) {
                down  = up + 1;
            }
        }
        return max(up, down);
    }
};
```



# 最长公共子序列

对于两个子序列 S1 和 S2，找出它们最长的公共子序列。

定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 dp[i][j] 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1<sub>i</sub> 与 S2<sub>j</sub> 值是否相等，分为两种情况：

- 当 S1<sub>i</sub>==S2<sub>j</sub> 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1<sub>i</sub> 这个值，最长公共子序列长度加 1，即` dp[i][j] = dp[i-1][j-1] + 1`。
- 当 S1<sub>i</sub> != S2<sub>j</sub> 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，即` dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }`。

综上，最长公共子序列的状态转移方程为：

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ecd89a22-c075-4716-8423-e0ba89230e9a.jpg" width="450px"> </div><br>

对于长度为 N 的序列 S<sub>1</sub> 和长度为 M 的序列 S<sub>2</sub>，`dp[N][M] `就是序列 S<sub>1</sub> 和序列 S<sub>2</sub> 的最长公共子序列长度。

与最长递增子序列相比，最长公共子序列有以下不同点：

- 针对的是两个序列，求它们的最长公共子序列。
- 在最长递增子序列中，dp[i] 表示以 S<sub>i</sub> 为结尾的最长递增子序列长度，子序列必须包含 S<sub>i</sub> ；在最长公共子序列中，`dp[i][j]` 表示 S1 中前 i 个字符与 S2 中前 j 个字符的最长公共子序列长度，不一定包含 S1<sub>i</sub> 和 S2<sub>j</sub>。
- 在求最终解时，最长公共子序列中` dp[N][M] `就是最终解，而最长递增子序列中` dp[N] `不是最终解，因为以 S<sub>N</sub> 为结尾的最长递增子序列不一定是整个序列最长递增子序列，需要遍历一遍 dp 数组找到最大者。

## 1. 最长公共子序列

1143\. Longest Common Subsequence

[Leetcode](https://leetcode.com/problems/longest-common-subsequence/) / [力扣](https://leetcode-cn.com/problems/longest-common-subsequence/)

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n = text1.size();
        int m = text2.size();
        vector<vector<int> >f(n + 1, vector<int>(m + 1, 0));
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= m; j++) {
                if(text1[i - 1] == text2[j - 1]) {
                    f[i][j] = f[i - 1][j - 1] + 1;
                } else {
                    f[i][j] = max(f[i][j - 1], f[i - 1][j]);
                }
            }
        }
        return f[n][m];
    }
};
```

# 0-1 背包

有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。

定义一个二维数组 dp 存储最大价值，其中` dp[i][j] `表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：

- 第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，`dp[i][j] = dp[i-1][j]`。
- 第 i 件物品添加到背包中，`dp[i][j] = dp[i-1][j-w] + v`。

第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8cb2be66-3d47-41ba-b55b-319fc68940d4.png" width="400px"> </div><br>

```cpp
// W 为背包总体积
// N 为物品数量
// weights 数组存储 N 个物品的重量
// values 数组存储 N 个物品的价值
int knapsack(int W, int N, int[] weights, int[] values) {
    vector<vector<int>>dp(N + 1, vector<int>(W + 1, 0));
    for(int i = 1; i <= N; i++) {
        int w = weigt[i - 1], v = values[i - 1];
        for(int j = 1; j <= W; j++) {
            if(j >= w) {
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w] + v);
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[N][W];
}
```

**空间优化**  

在程序实现时可以对 0-1 背包做优化。观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 `dp[i-1][j] `也可以表示` dp[i][j]`。此时，

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9ae89f16-7905-4a6f-88a2-874b4cac91f4.jpg" width="300px"> </div><br>

因为` dp[j-w]` 表示` dp[i-1][j-w]`，因此不能先求` dp[i][j-w]`，防止将` dp[i-1][j-w]` 覆盖。也就是说要先计算` dp[i][j] `再计算` dp[i][j-w]`，在程序实现时需要按倒序来循环求解。

```cpp
// W 为背包总体积
// N 为物品数量
// weights 数组存储 N 个物品的重量
// values 数组存储 N 个物品的价值
int knapsack(int W, int N, int[] weights, int[] values) {
    vector<vector<int>>dp(N + 1, vector<int>(W + 1, 0));
    for(int i = 1; i <= N; i++) {
        int w = weigt[i - 1], v = values[i - 1];
        for(int j = W; j >= 1; j--) {
            if(j >= w) {
                dp[j] = max(dp[j], dp[j - w] + v);
            }
        }
    }
    return dp[W];
}
```

