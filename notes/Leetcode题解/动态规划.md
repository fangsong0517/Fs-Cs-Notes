递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。

# 斐波那契数列

## [1. 爬楼梯]()

70. Climbing Stairs (Easy)

[Leetcode](https://leetcode.com/problems/climbing-stairs/description/) / [力扣](https://leetcode-cn.com/problems/climbing-stairs/description/)

题目描述：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。

定义一个数组 dp 存储上楼梯的方法数（为了方便讨论，数组下标从 1 开始），dp[i] 表示走到第 i 个楼梯的方法数目。

第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。

![img](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/14fe1e71-8518-458f-a220-116003061a83.png)



考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 空间复杂度优化为 O(1) 复杂度。

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if(n == 1 || n == 0) return n;
        vector<int>f(n + 1, 0);
        f[1] = 1;
        f[2] = 2;
        for(int i = 3; i <= n; i++) {
            f[i] = f[i - 1] + f[i - 2];
        }
        return f[n];
    }
};
```

## [2. 强盗抢劫]()

198. House Robber (Easy)

[Leetcode](https://leetcode.com/problems/house-robber/description/) / [力扣](https://leetcode-cn.com/problems/house-robber/description/)

题目描述：抢劫一排住户，但是不能抢邻近的住户，求最大抢劫量。

定义 dp 数组用来存储最大的抢劫量，**其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量**。

由于不能抢劫邻近住户，**如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户**，所以

![img](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/2de794ca-aa7b-48f3-a556-a0e2708cb976.jpg)

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        vector<int>dp(nums.size(), 0);
        if(nums.size() == 1) return nums[0];
        if(nums.size() == 2) return max(nums[0], nums[1]);
        if(nums.size() == 0)return 0;
        dp[0] = nums[0];
        dp[1] = max(nums[1], nums[0]);
        for(int i = 2; i < nums.size(); i++) {
            dp[i] = max(dp[i - 2] + nums[i] , dp[i - 1]);
        }
        return dp[nums.size() - 1];
    }
};
```

## [3. 强盗在环形街区抢劫]()

213. House Robber II (Medium)

[Leetcode](https://leetcode.com/problems/house-robber-ii/description/) / [力扣](https://leetcode-cn.com/problems/house-robber-ii/description/)

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        int n = nums.size();
        if(n==1) return nums[0];
        return max(func(nums, 0, n - 2),func(nums, 1, n - 1));
    }
    int func(vector<int>& nums, int l, int r) {
        int pre2 = 0, pre1 = 0;
        for(int i = l; i <= r; i++) {
            int cur = max(pre2 + nums[i], pre1);
            pre2 = pre1;
            pre1 = cur;
        }
        return pre1;
    }
};
```

## [4. 信件错排]()

题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量。

定义一个数组 dp 存储错误方式数量，**dp[i] 表示前 i 个信和信封的错误方式数量**。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：

- i==k，交换 i 和 j 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式。
- i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式。

综上所述，错误装信数量方式数量为：

![img](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/da1f96b9-fd4d-44ca-8925-fb14c5733388.png)



定义一个数组dp[]存储错误方式数量。dp[i]表示，有i封信、i个信箱情况下的错误装信方法总数。

对于第N封信而言，假设其装在了第 K 个信箱中，对于第 K 封信，有两种情况，

（1）信件 K 装在信箱 N 中；（2）信件 K 未被装在信箱 N 中。

**1. 信件K装在信箱N中**

如下图所示：
![技术图片](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/20200703mail1.png)
我们不看 K 和 N 两对信件和信箱，只关注剩下 N-2 对信件和信箱，有 dp[N-2] 种错误装信方法。同时， K 的取值范围： 1~N-1 ，因此共有 (N-1)*dp[N-2] 种错误装信方法。

**2. 信件 K 未被装在信箱 N 中**

如下图所示：
![技术图片](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/20200703mail2.png)

先给出结果，该情况的错误装信方法有 (N-1)*dp[N-1] 种。这个 dp[N-1] 是如何得出来，我思考了良久。

我们把问题重新描述一下，思路就会清晰很多。事实上，对于信件 i 来说，信箱 i 是它的“专属信箱”，每个信件都不能放入自己的专属信箱，对于n 个信件而言，都需要找其它 n-1 个信箱放入，其错排方法数为 dp[n] 。

问题的症结在于，对于上图中的信件 K 来说，其专属信箱，即 K 信箱已经被占用。

但是，我们可以把信箱 N 当做信件 K 的“专属信箱”，因为本情况下，信件 K 也不能放入信箱 N 。所以可以理解成求 N-1 封信件和 N-1 个信箱（除去信件 N）之间的错排数量问题。所以得到 dp[N-1]。

同理 K 的取值范围： 1~N-1 ，因此共有 (N-1)*dp[N-1] 种错误装信方法。

## 5. 母牛生产

题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。

第 i 年成熟的牛的数量为：

![img](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/879814ee-48b5-4bcb-86f5-dcc400cb81ad.png)

# 矩阵路径

## 1. 矩阵的最小路径和

64. Minimum Path Sum (Medium)

    [Leetcode](https://leetcode.com/problems/minimum-path-sum/description/) / [力扣](https://leetcode-cn.com/problems/minimum-path-sum/description/)

    ```html
    [[1,3,1],
     [1,5,1],
     [4,2,1]]
    Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum.Copy to clipboardErrorCopied
    ```

    题目描述：求从矩阵的左上角到右下角的最小路径和，每次只能向右和向下移动。

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        vector<vector<int>>dp(n, vector<int>(m, 0));
        for(int i = 0; i < n; i ++) {
            for(int j = 0; j < m; j++) {
                if(i == 0 && j!= 0) {
                    dp[i][j] = dp[i][j - 1] + grid[i][j];
                } else if(i != 0 && j == 0) {
                    dp[i][j] = dp[i - 1][j] + grid[i][j];
                } else if(i == 0 && j == 0) {
                    dp[i][j] = grid[i][j];
                } else {
                    dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];
                }
            }
        }
        return dp[n - 1][m - 1];
    }
};
```

## [2. 矩阵的总路径数]()

62. Unique Paths (Medium)

[Leetcode](https://leetcode.com/problems/unique-paths/description/) / [力扣](https://leetcode-cn.com/problems/unique-paths/description/)

题目描述：统计从矩阵左上角到右下角的路径总数，每次只能向右或者向下移动。

![img](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/dc82f0f3-c1d4-4ac8-90ac-d5b32a9bd75a.jpg)

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>>f(n, vector<int>(m, 1));
        for(int i = 1; i < n; i++) {
            for(int j = 1; j < m; j++) {
                f[i][j] = f[i - 1][j] + f[i][j - 1];
            }
        }
        return f[n - 1][m - 1];
    }
};
```

# 数组区间

## 1. 数组区间和

303. Range Sum Query - Immutable (Easy)

[Leetcode](https://leetcode.com/problems/range-sum-query-immutable/description/) / [力扣](https://leetcode-cn.com/problems/range-sum-query-immutable/description/)

```html
Given nums = [-2, 0, 3, -5, 2, -1]

sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3Copy to clipboardErrorCopied
```

求区间 i ~ j 的和，可以转换为 sum[j + 1] - sum[i]，其中 sum[i] 为 0 ~ i - 1 的和

```cpp
class NumArray {
public:
    vector<int>S;
    NumArray(vector<int>& nums) {
        int n = nums.size();
        S.resize(n + 1, 0);
        for(int i = 1; i <= nums.size(); i++) {
            S[i] = S[i - 1] + nums[i - 1];
        }
    }
    
    int sumRange(int i, int j) {
        return S[j + 1] - S[i];
    }
};

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray* obj = new NumArray(nums);
 * int param_1 = obj->sumRange(i,j);
 */
```

## 2. 数组中等差递增子区间的个数

413. Arithmetic Slices (Medium)

[Leetcode](https://leetcode.com/problems/arithmetic-slices/description/) / [力扣](https://leetcode-cn.com/problems/arithmetic-slices/description/)

```html
A = [0, 1, 2, 3, 4]

return: 6, for 3 arithmetic slices in A:

[0, 1, 2],
[1, 2, 3],
[0, 1, 2, 3],
[0, 1, 2, 3, 4],
[1, 2, 3, 4],
[2, 3, 4]
```

dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数。

当 A[i] - A[i-1] == A[i-1] - A[i-2]，那么 [A[i-2], A[i-1], A[i]] 构成一个等差递增子区间。而且在以 A[i-1] 为结尾的递增子区间的后面再加上一个 A[i]，一样可以构成新的递增子区间。

```html
dp[2] = 1
    [0, 1, 2]
dp[3] = dp[2] + 1 = 2
    [0, 1, 2, 3], // [0, 1, 2] 之后加一个 3
    [1, 2, 3]     // 新的递增子区间
dp[4] = dp[3] + 1 = 3
    [0, 1, 2, 3, 4], // [0, 1, 2, 3] 之后加一个 4
    [1, 2, 3, 4],    // [1, 2, 3] 之后加一个 4
    [2, 3, 4]        // 新的递增子区间
```

综上，在 A[i] - A[i-1] == A[i-1] - A[i-2] 时，dp[i] = dp[i-1] + 1。

因为递增子区间不一定以最后一个元素为结尾，可以是任意一个元素结尾，因此需要返回 dp 数组累加的结果。

```cpp
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& A) {
        if(A.size() == 0) return 0;
        int n = A.size();
        vector<int>dp(n + 1, 0);
        for(int i = 2; i < n; i++) {
            if(A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {
                dp[i] = dp[i - 1] + 1;
            }
        }
        int t = 0;
        for(int i = 0; i < dp.size(); i++) {
            t += dp[i];
        }
        return t;
    }
};
```

# 分割整数

## 1. 分割整数的最大乘积

343. Integer Break (Medim)

[Leetcode](https://leetcode.com/problems/integer-break/description/) / [力扣](https://leetcode-cn.com/problems/integer-break/description/)

题目描述：For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).

![image-20201111232728333](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20201111232728333.png)

```cpp
class Solution {
public:
    int integerBreak(int n) {
        vector<int>dp(n + 1, 0);
        dp[1] = 1;
        for(int i = 2; i <= n; i++) {
            for(int j = 1; j <= i - 1; j++) {
                dp[i] = max(dp[i], max(j * dp[i - j], j * (i - j)));
            }
        }
        return dp[n];
    }
};
```



**方法二：**

> 以下数学推导总体分为两步：① 当所有拆分出的数字相等时，乘积最大。② 最优拆分数字为 3 。

![image-20201111233143171](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20201111233143171.png)

![image-20201111233200246](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20201111233200246.png)

![Picture2.png](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/1d32896766463a7a74ffafe47e7f57008e563b8fe7a8e4d52525732ac8d34275-Picture2.png)

```cpp
//尽可能多分出几个3
class Solution {
public:
    int integerBreak(int n) {
        if(n == 2) return 1;
        if(n == 3) return 2;
        int a = 1;
        while(n > 4) {
            n = n - 3;
            a = a * 3;
        }
        return a * n;
    }
};
```

