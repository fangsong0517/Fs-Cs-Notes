递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。

# 斐波那契数列

## [1. 爬楼梯]()

70. Climbing Stairs (Easy)

[Leetcode](https://leetcode.com/problems/climbing-stairs/description/) / [力扣](https://leetcode-cn.com/problems/climbing-stairs/description/)

题目描述：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。

定义一个数组 dp 存储上楼梯的方法数（为了方便讨论，数组下标从 1 开始），dp[i] 表示走到第 i 个楼梯的方法数目。

第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。

![img](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/14fe1e71-8518-458f-a220-116003061a83.png)



考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 空间复杂度优化为 O(1) 复杂度。

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if(n == 1 || n == 0) return n;
        vector<int>f(n + 1, 0);
        f[1] = 1;
        f[2] = 2;
        for(int i = 3; i <= n; i++) {
            f[i] = f[i - 1] + f[i - 2];
        }
        return f[n];
    }
};
```

## [2. 强盗抢劫]()

198. House Robber (Easy)

[Leetcode](https://leetcode.com/problems/house-robber/description/) / [力扣](https://leetcode-cn.com/problems/house-robber/description/)

题目描述：抢劫一排住户，但是不能抢邻近的住户，求最大抢劫量。

定义 dp 数组用来存储最大的抢劫量，**其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量**。

由于不能抢劫邻近住户，**如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户**，所以

![img](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/2de794ca-aa7b-48f3-a556-a0e2708cb976.jpg)

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        vector<int>dp(nums.size(), 0);
        if(nums.size() == 1) return nums[0];
        if(nums.size() == 2) return max(nums[0], nums[1]);
        if(nums.size() == 0)return 0;
        dp[0] = nums[0];
        dp[1] = max(nums[1], nums[0]);
        for(int i = 2; i < nums.size(); i++) {
            dp[i] = max(dp[i - 2] + nums[i] , dp[i - 1]);
        }
        return dp[nums.size() - 1];
    }
};
```

## [3. 强盗在环形街区抢劫]()

213. House Robber II (Medium)

[Leetcode](https://leetcode.com/problems/house-robber-ii/description/) / [力扣](https://leetcode-cn.com/problems/house-robber-ii/description/)

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        int n = nums.size();
        if(n==1) return nums[0];
        return max(func(nums, 0, n - 2),func(nums, 1, n - 1));
    }
    int func(vector<int>& nums, int l, int r) {
        int pre2 = 0, pre1 = 0;
        for(int i = l; i <= r; i++) {
            int cur = max(pre2 + nums[i], pre1);
            pre2 = pre1;
            pre1 = cur;
        }
        return pre1;
    }
};
```

## [4. 信件错排]()

题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量。

定义一个数组 dp 存储错误方式数量，**dp[i] 表示前 i 个信和信封的错误方式数量**。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：

- i==k，交换 i 和 j 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式。
- i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式。

综上所述，错误装信数量方式数量为：

![img](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/da1f96b9-fd4d-44ca-8925-fb14c5733388.png)



定义一个数组dp[]存储错误方式数量。dp[i]表示，有i封信、i个信箱情况下的错误装信方法总数。

对于第N封信而言，假设其装在了第 K 个信箱中，对于第 K 封信，有两种情况，

（1）信件 K 装在信箱 N 中；（2）信件 K 未被装在信箱 N 中。

**1. 信件K装在信箱N中**

如下图所示：
![技术图片](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/20200703mail1.png)
我们不看 K 和 N 两对信件和信箱，只关注剩下 N-2 对信件和信箱，有 dp[N-2] 种错误装信方法。同时， K 的取值范围： 1~N-1 ，因此共有 (N-1)*dp[N-2] 种错误装信方法。

**2. 信件 K 未被装在信箱 N 中**

如下图所示：
![技术图片](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/20200703mail2.png)

先给出结果，该情况的错误装信方法有 (N-1)*dp[N-1] 种。这个 dp[N-1] 是如何得出来，我思考了良久。

我们把问题重新描述一下，思路就会清晰很多。事实上，对于信件 i 来说，信箱 i 是它的“专属信箱”，每个信件都不能放入自己的专属信箱，对于n 个信件而言，都需要找其它 n-1 个信箱放入，其错排方法数为 dp[n] 。

问题的症结在于，对于上图中的信件 K 来说，其专属信箱，即 K 信箱已经被占用。

但是，我们可以把信箱 N 当做信件 K 的“专属信箱”，因为本情况下，信件 K 也不能放入信箱 N 。所以可以理解成求 N-1 封信件和 N-1 个信箱（除去信件 N）之间的错排数量问题。所以得到 dp[N-1]。

同理 K 的取值范围： 1~N-1 ，因此共有 (N-1)*dp[N-1] 种错误装信方法。

## [5. 母牛生产](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode 题解 - 动态规划?id=_5-母牛生产)

[程序员代码面试指南-P181](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode 题解 - 动态规划?id)

题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。

第 i 年成熟的牛的数量为：

![img](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/879814ee-48b5-4bcb-86f5-dcc400cb81ad.png)

# 矩阵路径

## [1. 矩阵的最小路径和](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode 题解 - 动态规划?id=_1-矩阵的最小路径和)

64. Minimum Path Sum (Medium)

    [Leetcode](https://leetcode.com/problems/minimum-path-sum/description/) / [力扣](https://leetcode-cn.com/problems/minimum-path-sum/description/)

    ```html
    [[1,3,1],
     [1,5,1],
     [4,2,1]]
    Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum.Copy to clipboardErrorCopied
    ```

    题目描述：求从矩阵的左上角到右下角的最小路径和，每次只能向右和向下移动。

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        vector<vector<int>>dp(n, vector<int>(m, 0));
        for(int i = 0; i < n; i ++) {
            for(int j = 0; j < m; j++) {
                if(i == 0 && j!= 0) {
                    dp[i][j] = dp[i][j - 1] + grid[i][j];
                } else if(i != 0 && j == 0) {
                    dp[i][j] = dp[i - 1][j] + grid[i][j];
                } else if(i == 0 && j == 0) {
                    dp[i][j] = grid[i][j];
                } else {
                    dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];
                }
            }
        }
        return dp[n - 1][m - 1];
    }
};
```

## [2. 矩阵的总路径数]()

62. Unique Paths (Medium)

[Leetcode](https://leetcode.com/problems/unique-paths/description/) / [力扣](https://leetcode-cn.com/problems/unique-paths/description/)

题目描述：统计从矩阵左上角到右下角的路径总数，每次只能向右或者向下移动。

![img](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/dc82f0f3-c1d4-4ac8-90ac-d5b32a9bd75a.jpg)

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>>f(n, vector<int>(m, 1));
        for(int i = 1; i < n; i++) {
            for(int j = 1; j < m; j++) {
                f[i][j] = f[i - 1][j] + f[i][j - 1];
            }
        }
        return f[n - 1][m - 1];
    }
};
```

