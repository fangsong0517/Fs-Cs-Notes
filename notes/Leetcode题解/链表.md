# 链表

链表是空节点，或者有一个值和一个指向下一个链表的指针，因此很多链表问题可以用递归来处理。

## 1. 找出两个链表的交点

160. Intersection of Two Linked Lists (Easy)

[Leetcode (opens new window)](https://leetcode.com/problems/intersection-of-two-linked-lists/description/)/ [力扣(opens new window)](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/)

例如以下示例中 A 和 B 两个链表相交于 c1：

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *A = headA;
        ListNode *B = headB;
        while(A != B) {
            A = (A == NULL) ? headB : A->next;
            B = (B == NULL) ? headA : B->next;
        }
        return A;
    }
};
```

## 2. 链表反转

206. Reverse Linked List (Easy)

[Leetcode (opens new window)](https://leetcode.com/problems/reverse-linked-list/description/)/ [力扣](https://leetcode-cn.com/problems/reverse-linked-list/description/)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head == NULL) return head;
        ListNode ret;
        ret.next = NULL;
        ListNode *p = head, *q;
        while(p) {
            q = p->next;
            p->next = ret.next;
            ret.next = p;
            p = q;
        }
        return ret.next;
    }
};
```

