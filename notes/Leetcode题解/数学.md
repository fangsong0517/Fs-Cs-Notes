# LeetCode题解-数学

# 素数分解

每一个数都可以分解成素数的乘积，例如 84 = 2<sup>2</sup> \* 3<sup>1</sup> \* 5<sup>0</sup> \* 7<sup>1</sup> \* 11<sup>0</sup> \* 13<sup>0</sup> \* 17<sup>0</sup> \* …

# 整除

令 x = 2<sup>m0</sup> \* 3<sup>m1</sup> \* 5<sup>m2</sup> \* 7<sup>m3</sup> \* 11<sup>m4</sup> \* …

令 y = 2<sup>n0</sup> \* 3<sup>n1</sup> \* 5<sup>n2</sup> \* 7<sup>n3</sup> \* 11<sup>n4</sup> \* …

如果 x 整除 y（y mod x == 0），则对于所有 i，mi <= ni。

# 最大公约数最小公倍数

x 和 y 的最大公约数为：gcd(x,y) =  2<sup>min(m0,n0)</sup> \* 3<sup>min(m1,n1)</sup> \* 5<sup>min(m2,n2)</sup> \* ...

x 和 y 的最小公倍数为：lcm(x,y) =  2<sup>max(m0,n0)</sup> \* 3<sup>max(m1,n1)</sup> \* 5<sup>max(m2,n2)</sup> \* ...

## 1. 生成素数序列

204\. Count Primes (Easy)

[Leetcode](https://leetcode.com/problems/count-primes/description/) / [力扣](https://leetcode-cn.com/problems/count-primes/description/)

埃拉托斯特尼筛法在每次找到一个素数时，将能被素数整除的数排除掉。

```cpp
class Solution {
public:
    int prime[5000050];
    void f(int n) {
        for(int i = 2; i <= n; i++) {
            for(int j = i * 2; j <= n; j += i) {
                prime[j] = 1;
            }
        }
    }
    int countPrimes(int n) {
        f(n);
        int sum = 0;
        for(int i = 2; i < n; i++) {
            if(!prime[i]) {
                sum ++;
            }
        }
        return sum;
    }
};
```

## 2. 最大公约数

```java
int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}
```

最小公倍数为两数的乘积除以最大公约数。

```java
int lcm(int a, int b) {
    return a * b / gcd(a, b);
}
```

## 3. 使用位操作和减法求解最大公约数

[编程之美：2.7](#)

对于 a 和 b 的最大公约数 f(a, b)，有：

- 如果 a 和 b 均为偶数，f(a, b) = 2\*f(a/2, b/2);
- 如果 a 是偶数 b 是奇数，f(a, b) = f(a/2, b);
- 如果 b 是偶数 a 是奇数，f(a, b) = f(a, b/2);
- 如果 a 和 b 均为奇数，f(a, b) = f(b, a-b);

乘 2 和除 2 都可以转换为移位操作。



# 进制转换

## 1. 7 进制

504\. Base 7 (Easy)

[Leetcode](https://leetcode.com/problems/base-7/description/) / [力扣](https://leetcode-cn.com/problems/base-7/description/)

```cpp
class Solution {
public:
    string convertToBase7(int num) {
        if(num == 0) return "0";
        string w = "";
        int flag = 0;
        if(num < 0) {
            flag = 1;
            num = -1 * num;
        }
        while(num) {
            w += (num % 7 + '0');
            num /= 7;
        }
        while(w.size() > 1 && w.back() == '0') w.pop_back();
        reverse(w.begin(), w.end());
        return flag ? '-' + w : w;
    }
};
```

## 2. 16 进制

405. Convert a Number to Hexadecimal (Easy)

[Leetcode (opens new window)](https://leetcode.com/problems/convert-a-number-to-hexadecimal/description/)/ [力扣(opens new window)](https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/description/)

```html
Input:
26

Output:
"1a"

Input:
-1

Output:
"ffffffff"
```

负数要用它的补码形式。

```cpp
class Solution {
public:
    string toHex(int num) {
        if(num == 0) return "0";
        string hex = "0123456789abcdef", ans = "";
        while(num && ans.size() < 8) {
            ans = hex[num & 0xf] + ans;
            num >>= 4;
        }
        return ans;
    }
};
```

## 3. 26 进制

168. Excel Sheet Column Title (Easy)

[Leetcode (opens new window)](https://leetcode.com/problems/excel-sheet-column-title/description/)/ [力扣(opens new window)](https://leetcode-cn.com/problems/excel-sheet-column-title/description/)

```html
1 -> A
2 -> B
3 -> C
...
26 -> Z
27 -> AA
28 -> AB
```

因为是从 1 开始计算的，而不是从 0 开始，因此需要对 n 执行 -1 操作。

```cpp
class Solution {
public:
    string convertToTitle(int n) {
        if(n == 0) return "";
        string s;
        while(n) {
            n--;
            s += char(n % 26 + 'A');
            n /= 26;
        }
        reverse(s.begin(), s.end());
        return s;
    }
};
```

# 阶乘

### 1. 统计阶乘尾部有多少个 0

172. Factorial Trailing Zeroes (Easy)

[Leetcode (opens new window)](https://leetcode.com/problems/factorial-trailing-zeroes/description/)/ [力扣(opens new window)](https://leetcode-cn.com/problems/factorial-trailing-zeroes/description/)

尾部的 0 由 2 * 5 得来，2 的数量明显多于 5 的数量，因此只要统计有多少个 5 即可。

对于一个数 N，它所包含 5 的个数为：N/5 + N/52 + N/53 + ...，其中 N/5 表示不大于 N 的数中 5 的倍数贡献一个 5，N/52 表示不大于 N 的数中 52 的倍数再贡献一个 5 ...。

```java
class Solution {
public:
    int trailingZeroes(int n) {
        int w = 0;
        while(n) {
            w += n / 5;
            n /= 5;
        }
        return w;
    }

};
```

如果统计的是 N! 的二进制表示中最低位 1 的位置，只要统计有多少个 2 即可，该题目出自 [编程之美：2.2](http://www.cyc2018.xyz/算法/Leetcode 题解/Leetcode 题解 - 数学.html#) 。和求解有多少个 5 一样，2 的个数为 N/2 + N/22 + N/23 + ...

# 字符串加法减法

### 1. 二进制加法

67. Add Binary (Easy)

[Leetcode (opens new window)](https://leetcode.com/problems/add-binary/description/)/ [力扣(opens new window)](https://leetcode-cn.com/problems/add-binary/description/)

```cpp
class Solution {
public:
    vector<int>add(vector<int>&A, vector<int>&B) {
        vector<int>C;
        int t = 0;
        for(int i = 0; i < A.size() || i < B.size(); i++) {
            if(i < A.size()) t += A[i];
            if(i < B.size()) t += B[i];
            C.push_back(t % 2);
            t /= 2;
        }
        if(t) C.push_back(1);
        return C;
    }
    string addBinary(string a, string b) {
        vector<int>A, B;
        for(int i = a.size() - 1; i >= 0; i--) {
            A.push_back(a[i] - '0');
        }
        for(int i = b.size() - 1; i >= 0; i--) {
            B.push_back(b[i] - '0');
        }
        auto C = add(A, B);
        string s = "";
        for(int i = C.size() - 1; i >= 0; i--) {
            s += C[i] + '0';
        }
        return s;
    }
};
```

### 2. 字符串加法

415. Add Strings (Easy)

[Leetcode (opens new window)](https://leetcode.com/problems/add-strings/description/)/ [力扣(opens new window)](https://leetcode-cn.com/problems/add-strings/description/)

字符串的值为非负整数。

```cpp
class Solution {
public:
    vector<int>add(vector<int>&A, vector<int>&B) {
        vector<int>C;
        int t = 0;
        for(int i = 0; i < A.size() || i < B.size(); i++) {
            if(i < A.size()) t += A[i];
            if(i < B.size()) t += B[i];
            C.push_back(t % 10);
            t /= 10;
        }
        if(t) C.push_back(1);
        return C;
    }

    string addStrings(string a, string b) {
        vector<int>A, B;
        for(int i = a.size() - 1; i >= 0; i--) {
            A.push_back(a[i] - '0');
        }
        for(int i = b.size() - 1; i >= 0; i--) {
            B.push_back(b[i] - '0');
        }
        auto C = add(A, B);
        string s = "";
        for(int i = C.size() - 1; i >= 0; i--) {
            s += C[i] + '0';
        }
        return s;
    }
};
```

