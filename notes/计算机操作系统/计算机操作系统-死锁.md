![image-20201119225606486](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20201119225606486.png)

那么为什么会产生死锁呢？
1.因为系统资源不足。
2.进程运行推进的顺序不合适。  
3.资源分配不当。

# 必要条件

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c037c901-7eae-4e31-a1e4-9d41329e5c3e.png"/> </div><br>

Resource allocation graphs  资源分配图

Holding a resource 持有资源

requesting a resource 请求资源

deadlock 僵局

* 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。所以所谓的互斥是指：资源不共享，如果被使用，只能被一个进程使用。
* 占有和等待：已经得到了某个资源的进程可以再请求新的资源。

- 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

# 处理方法

主要有以下四种方法：

- 鸵鸟策略
- 死锁检测与死锁恢复
- 死锁预防
- 死锁避免

# 鸵鸟策略

把头埋在沙子里，假装根本没发生问题。

因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。

当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。



# 死锁检测与死锁恢复

不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

## 1. 每种类型一个资源的死锁检测

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1fa0453-a4b0-4eae-a352-48acca8fff74.png"/> </div><br>

上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。

图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。

每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。

## 2. 每种类型多个资源的死锁检测

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png"/> </div><br>

上图中，有三个进程四个资源，每个数据代表的含义如下：

- E 向量：资源总量
- A 向量：资源剩余量
- C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量
- R 矩阵：每个进程请求的资源数量

进程 P<sub>1</sub> 和 P<sub>2</sub> 所请求的资源都得不到满足，只有进程 P<sub>3</sub> 可以，让 P<sub>3</sub> 执行，之后释放 P<sub>3</sub> 拥有的资源，此时 A = (2 2 2 0)。P<sub>2</sub> 可以执行，执行后释放 P<sub>2</sub> 拥有的资源，A = (4 2 2 1) 。P<sub>1</sub> 也可以执行。所有进程都可以顺利执行，没有死锁。

算法总结如下：

每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。

1. 寻找一个没有标记的进程 P<sub>i</sub>，它所请求的资源小于等于 A。
2. 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。
3. 如果没有这样一个进程，算法终止。

## 3. 死锁恢复

- 利用抢占恢复
- 利用回滚恢复
- 通过杀死进程恢复

# 死锁预防

在程序运行之前预防发生死锁。

## 1. 破坏互斥条件

例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。

**方法**：

   如果允许系统资源都能共享使用，则系统不会进入死锁状态。

**缺点**：

   有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。所以，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该保护这种互斥性。

## 2. 破坏占有和等待条件

一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。

**方法**：

   釆用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。

**缺点**：

   系统资源被严重浪费，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。而且还会导致“饥饿”现象，当由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行。

## 3. 破坏不可抢占条件

**方法**：

   当一个已保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺了，或从而破坏了不可剥夺条件。

**缺点**：

   该策略实现起来比较复杂，释放已获得的资源可能造成前一阶段工作的失效，反复地申请和释放资源会增加系统开销，降低系统吞吐量。这种方法常用于状态易于保存和恢复的资源，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源。

## 4. 破坏环路等待

给资源统一编号，进程只能按编号顺序来请求资源。

**方法**：

   为了破坏循环等待条件，可釆用顺序资源分配法。首先给系统中的资源编号，规定每个进程，必须按编号递增的顺序请求资源，同类资源一次申请完。也就是说，只要进程提出申请分配资源Ri，则该进程在以后的资源申请中，只能申请编号大于Ri的资源。

**缺点**：

   这种方法存在的问题是，编号必须相对稳定，这就限制了新类型设备的增加；尽管在为资源编号时已考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源的浪费；此外，这种按规定次序申请资源的方法，也必然会给用户的编程带来麻烦。

# 死锁避免

在程序运行时避免发生死锁。

## 1. 安全状态

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed523051-608f-4c3f-b343-383e2d194470.png"/> </div><br>

图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。

定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。

安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。

## 2. 单个资源的银行家算法

一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png"/> </div><br>

上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。

## 3. 多个资源的银行家算法

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png"/> </div><br>

上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。

检查一个状态是否安全的算法如下：

- 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。
- 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。
- 重复以上两步，直到所有进程都标记为终止，则状态时安全的。

如果一个状态不是安全的，需要拒绝进入这个状态。

# 死锁的事例

当一个多线程程序中存在多个互斥资源时，就有可能造成死锁。比如有两个线程T1和T2,两个互斥锁A和B，线程T1拿到了锁A，在等待锁B，一直到等到B才能往下执行，释放锁A，而此时线程T2拿到了锁B，在等待锁A，一直到等到A才能往下执行，然后释放锁B。即线程T1和T2在等对方持有的锁，又都不肯释放锁，这时候线程T1和T2就会一直等下去了，在等待，永远在等待。这就是死锁。

```cpp
#include <iostream>
#include <thread>
#include <mutex>
 
std::mutex mtxA;
std::mutex mtxB;
 
void threadT1()
{
    	std::unique_lock<std::mutex> lockA(mtxA);
	std::cout << "threasT1 got mtxA" << std::endl;
	// 线程1睡眠2s再获取锁B，保证锁B先被线程2获取，模拟死锁问题的发生
	std::this_thread::sleep_for(std::chrono::seconds(2));
 
	std::cout << "threasT1 try to get mtxB" << std::endl;
	std::unique_lock<std::mutex> lockB(mtxB);
	std::cout << "threasT1 got mtxB" << std::endl;
	std::cout << "threasT1 quit" << std::endl;	
}
 
 
void threadT2()
{
	std::unique_lock<std::mutex> lockB(mtxB);
	std::cout << "threasT2 got mtxB" << std::endl;
	// 线程2睡眠2s再获取锁A，保证锁A先被线程1获取，模拟死锁问题的发生
	std::this_thread::sleep_for(std::chrono::seconds(2));
 
	std::cout << "threasT2 try to get mtxA" << std::endl;
	std::unique_lock<std::mutex> lockA(mtxA);
	std::cout << "threasT2 got mtxA" << std::endl;
	std::cout << "threasT2 quit" << std::endl;
}
 
int main()
{
	std::thread t1(threadT1);
	std::thread t2(threadT2);
	// main主线程等待所有子线程执行完
	t1.join();
	t2.join();
	std::cout << "threasT1 threasT2 all quit" << std::endl;
	system("pause");
	return 0;
}
```

线程1一直在等待资源B，线程B一直在等待资源A，两个线程都在等待，没有退出。

由于多个线程获取多个锁资源的时候，顺序不一致导致的死锁问题，那么保证它们获取锁的顺序是一致的，问题就可以解决。针对上面的代码线程1和线程B都先获取A再获取B，修改线程2函数如下。

```cpp
void threadT2()
{
	std::unique_lock<std::mutex> lockA(mtxA);
	std::cout << "threasT2 got mtxA" << std::endl;
	// 线程2睡眠2s再获取锁A，保证锁A先被线程1获取，模拟死锁问题的发生
	std::this_thread::sleep_for(std::chrono::seconds(2));
 
	std::cout << "threasT2 try to get mtxB" << std::endl;
	std::unique_lock<std::mutex> lockB(mtxB);
	std::cout << "threasT2 got mtxB" << std::endl;
	std::cout << "threasT2 quit" << std::endl;
}
```

有以下几点

1、对类中成员函数加读写专用函数，专用函数中加互斥锁进行保护。

2、类中的成员函数要尽量避免在没有保护的情况下对某个成员变量的多次读取或者修改。

3、当一个加锁的函数中调用了另一个加锁函数时要注意检查连个函数的锁，如果是同一把锁，会造成死锁。

4、当一个函数中有多个线程使用多个锁时要检查有没有类似于第一部分相互等待的造成的死锁问题。

5、对于加锁的不可重入的函数，要使用pthread_mutex_trylock

  对一个函数加锁，只能保证一个函数不会被多个线程同时执行，但是无法避免多个线程先后执行同一个函数，这时可以使用try_lock函数。该如果互斥锁当前被另一个线程锁定，则该函数将失败并返回false，而不会阻塞。