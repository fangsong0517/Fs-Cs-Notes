# c++程序设计

## 从Ｃ到Ｃ＋＋

### 　C++语言简介

- C++是C的超集
- C++同时支持４中编程范式

	- 面向过程
	- 面向对象
	- 泛型编程
	- 函数式子编程

### C++的学习方法

- 从编程范式入手，将语言特性进行分类学习

### C++中STL的初步认识

- 强调使用cppreference
- queue,stack简介
- 左值引用介绍

	- 比指针更好的引用

- sort、nth_element方法的使用

	- HZOJ-245货仓选址

- string的使用

	- HZOJ-116字符串的操作

- map和set的使用

	- HZOJ-216获取名字并排序
	- HZOJ-287合并果子

- 使用类封装大整数

	- HZOJ-256国王游戏

## 封装

### 构造函数与析构函数

- 默认构造函数
- 有参构造函数
- 转换构造函数

	- 普通的转换构造函数应用
	- 函数传值过程中的转换构造函数的作用

- 拷贝构造函数

	- 拷贝构造函数的基本作用
	- 思考：拷贝构造函数为什么传入应用
	- 复制拷贝操作

- 析构函数

	- 需要资源回收的时候，就需要析构函数

- =default和=delete作用
- 三五法则

	- 1.需要析构函数的类也需要拷贝构造函数和拷贝赋值函数
	- 2.需要拷贝操作的类也需要渎职操作，反之亦然
	- 3.析构函数不能是删除的
	- 4.如果一个类有删除的或者不可访问的析构函数，那么其默认和拷贝构造函数会被定义为删除的
	- 如果一个类有const或引用成员，则不能使用合成的拷贝赋值操作

### 属性与方法

- 成员属性和方法
- 类属性的方法

	- 类属性必须在外部定义，static修饰的函数属于类属性成员

- const类型的方法与mutable关键字

### 运算符重载

- 类外重载运算符

	- 普通运算符重载
	- 重载cout的左移运算符

- 类内重载运算符

	- 普通运算符重载
	- 函数对象()、数组对象[]和指针对象->

- 其他重载知识

	- 不能重载的5个运算符

		- ．成员引用运算符
		- .*成员指针引用运算符
		- sizeof运算符
		- ?:唯一的三目运算符
		- ::作用域操作符

	- 只能在类内部重载4个操作符

		- ()函数括号运算符
		- []数组方括号运算符
		- ->间接引用运算符
		- =赋值运算符

### RVO/NRVO返回值优化

- 正常情况的拷贝操作
- 一次优化情况
- 二次优化情况
- g++用-fno-elide-constructors选项关闭返回值优化

## 继承

### 继承的基础知识

- 集成的基本语法结构
- 继承对对象大小的影响
- 父类指针与引用指向子类对象
- 父类数据与子类数据在内存中的存储结构
- 父类与子类数据在内存中的存储结构
- 父类与子类的构造与析构顺序
- 子类中调用父类中的同名方法，域作用运算符

### 继承权限的作用

- 子类的访问看父类中属性的权限
- 外部访问子类的父类属性，看子类的继承权限

### 多重继承

- 多重继承基本知识
- 菱形继承的困扰

	- 菱形继承对于调用对象方法，造成混淆，编译不通过
	- 菱形继承对于访问对象属性，造成混淆，干扰编码逻辑

- 解决菱形继承

	- 虚继承基础：virtual关键字-->对于重复的基类
	- 虚继承的对象模板

		- 虚基类表指针，用来索引虚部的位置
		- 对象内存分成虚部和实部，继承关系中：是不叠加，虚部整合

	- 结论：不要设计过于复杂的继承关系，项目中尽量不要使用虚继承

## 多态

### 非多态下的问题

- 父类指针调用无法调用子类同名方法

### 虚函数与纯虚函数

- 虚函数基本知识

	- virtual修饰的成员方法
	- 只要有继承，父类的析构函数一定要是虚函数

- 纯虚函数的继承知识

	- 纯虚函数的基础语法
	- 纯虚函数的性质：子类中必须对其实现
	- 抽象类的概念

- 总结：普通成员的函数跟这类走，虚函数跟着对象走
- 虚函数的对象模型

	- 虚函数表指针，用来索引虚函数
	- 用函数指针，调用虚函数表中的虚函数
	- 成员方法中的this指针说明

## 总结与思考

### 关键字思考

- auto关键字

	- auto在旧标准中的作用：表明具有自动存储期的变量
	- auto作用在编译期

		- 不能作为函数参数
		- 不能作为模板参数
		- 无法定义数组
		- 不能用于非静态成员变量

- constexpr关键字

	- 与const关键字的区别：一个是编译期常量，一个是运行期常量
	- constexpr修饰函数

		- 修饰普通函数
		- 修饰构造函数

- final关键字

	- 禁止类继承
	- 禁止虚函数重写

- nullptr关键字

	- NULL在C与C++中的区别
	- C++中NULL所带来的歧义：func(int), func(int *)
	- nullptr是空指针更准确、无歧义的语义表达

- override关键字

	- 为什么有override关键字

### 右值引用

- 四个概念

	- 左值与右值
	- 左值引用和右值引用
	- 非const变量绑定引用优先顺序
	- const变量绑定引用的优先顺序

- forward与nove
- move constructor移动构造

## 模板

### 模板的基础知识

- 定义模板函数的基本语法

	- template
	- typename与class模板参数关键字

- 定义没有bug的add模板

	- 1.定义一个参数的模板
- template<class T> T add(T a, T b);
		- 当a、b变量类型不同的时候，模板就会报错
		
- 2.定义两个参数的模板
	- template<class T, class U> ??? add(T a, U b);
	- 没有办法确定返回值类型
		
	- 3.typeof的升级decltype类型的推导
- decltype(T() + U())add(T a, U b)
		- 当T或者U类型没有默认构造函数的时候就会报错
	
	- 4.返回值类型后置语法
	
	- auto add(T a,U b)->decltype(a +b);
		- 当传入指针变量的时候，出错

	- 5.模板的片特化与特化
	
	- auto add(T *a, U *b) -> decltype(*a + *b)
		- 完美实现add模板函数

- 模板参数推导

	- 正常类型的推导

		- 隐式转换:add(a, b)
		- 显示转换：add<long long>(a, b)
		- 模板函数作为参数，传参时的间接类型推导

	- 引用类型的推导

		- 引用折叠
		- T、T &、T &&的作用
		- 只有T &&是正确的声明模板中的引用

			- 左值时，T为int &
			- 右值时，T为int

		- remove_reference的作用

- 标准类型转换模板

	- remove_reference

		- 去掉引用

	- add_const

		- 添加const限定

	- add_lvalue_reference

		- 转换成左值引用

	- add_rvalue_reference

		- 转换为右值引用

	- remove_pointer

		- 去掉指针类型

	- add_pointer

		- 变成指针类型

	- make_signed

		- 变成有符号类型

	- make_unsigned

		- 变成无符号类型

	- remove_extent

		- 去掉一层数组

	- remove_all_extent

		- 去掉所有层数组

- 模板函数move的实现
- 模板类

	- 模板类的基本介绍
	- 模板类的偏特化class A<T(ARGS...>{}

### 变参模板

- 变参模板的知识

	- 变参模板语法
	- 演示print末班函数递归展开变参列表

- 设计处理变参列表的模板类

	- 正向展开的ARG模板类
	- 反向展开的ARG模板类（传入整形模板参数n）

- 简版function模板类的实现

### 拓展知识

- 统计函数执行的次数

	- 面向对象的程序设计，使用function模板
	- 函数式编程的设计，使用bind与引用

		- ref的使用
		- std::placeholder::_1、_2...的介绍

- c++线程类thread介绍

	- thread的基本使用
	- thread构造函数与bind之间的关系

- 模板的图灵完备性演示

	- 判断数字是否是偶数
	- 求1到n的和值
	- 判断一个数字是都是素数
	- 求n以内所有素数和
	- 输出n以内的所有素数

*XMind - Trial Version*