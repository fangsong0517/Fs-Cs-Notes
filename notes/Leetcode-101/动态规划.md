# 动态规划

## 70. 爬楼梯

[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

```cpp
class Solution {
public:
    int climbStairs(int n) {
        long long a = 1, b = 2, sum = 0;
        for(int i = 1; i < n; i++) {
            sum = a + b;
            a = b;
            b = sum;
        }
        return a;
    }
};
```

## 198. 打家劫舍

[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

![image-20210129205342193](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20210129205342193.png)

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int pre2 = 0, pre1 = 0;
        for(int i = 0; i < nums.size(); i++) {
            int cur = max(pre2 + nums[i], pre1);
            pre2 = pre1;
            pre1 = cur;
        }
        return pre1;
    }
};
```

## 413. 等差数列划分

[413. 等差数列划分](https://leetcode-cn.com/problems/arithmetic-slices/)

```cpp
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& A) {
        int n = A.size();
        vector<int>dp(n, 0);
        for(int i = 2; i < n; i++) {
            if(A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {
                dp[i] = dp[i - 1] + 1;
            }
        }
        int sum = 0;
        for(int i = 0; i < n; i++) {
            sum += dp[i];
        }
        return sum;
    }
};
```

## 64. 最小路径和

[64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        vector<vector<int>>dp(n, vector<int>(m, 0));
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(i == 0 && j == 0) {
                    dp[i][j] = grid[i][j];
                } else if(i != 0 && j == 0) {
                    dp[i][j] = dp[i - 1][j] + grid[i][j];
                } else if(i == 0 && j != 0) {
                    dp[i][j] = dp[i][j - 1] + grid[i][j];
                } else {
                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
                }
            }
        }
        return dp[n - 1][m - 1];
    }
};
```

## 542. 01 矩阵

[542. 01 矩阵](https://leetcode-cn.com/problems/01-matrix/)

==BFS做法：==

```cpp
struct node{
    int x, y, z;
};
class Solution {
public:
    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};
    vector<vector<int>> updateMatrix(vector<vector<int>>& matrix) {
        int n = matrix.size();
        int m = matrix[0].size();
        vector<vector<int>>res(n, vector<int>(m, 0));
        vector<vector<int>>vis(n, vector<int>(m, 0));
        queue<node>q;
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j ++) {
                if(matrix[i][j] == 0) {
                    q.push({i, j, 0});
                    vis[i][j] = 1;
                }
            }
        }
        while(!q.empty()) {
            node tp = q.front();
            q.pop();
            for(int i = 0; i < 4; i++) {
                int dx = tp.x + dir[i][0];
                int dy = tp.y + dir[i][1];
                if(dx < 0 || dx >= n || dy < 0 || dy >= m || vis[dx][dy] == 1) continue;
                vis[dx][dy] = 1;
                res[dx][dy] = tp.z + 1;
                q.push({dx, dy, tp.z + 1});
            }
        }
        return res;
    }
};
```

==动态规划：==

一种办法是使用一个 dp 数组做 memoization,使得广度优先搜索不会重复遍历相同位置;另一种更简单的方法是,我们从左上到右下进行一次动态搜索,再从右下到左上进行一次动态搜索。两次动态搜索即可完成四个方向上的查找。

```cpp
class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& matrix) {
        if(matrix.empty()) return {};
        int n = matrix.size();
        int m = matrix[0].size();
        vector<vector<int>>dp(n, vector<int>(m, INT_MAX - 1));
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(matrix[i][j] == 0) {
                    dp[i][j] = 0;
                } else {
                    if(j > 0) {
                        dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1);
                    }
                    if(i > 0) {
                        dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1);
                    }
                }
            }
        }
        for(int i = n - 1; i >= 0; i--) {
            for(int j = m - 1; j >= 0; j--) {
                if(matrix[i][j] != 0) {
                    if(j < m - 1) {
                        dp[i][j] = min(dp[i][j], dp[i][j + 1] + 1);
                    }
                    if(i < n - 1) {
                        dp[i][j] = min(dp[i][j], dp[i + 1][j] + 1);
                    }
                }
            }
        }
        return dp;
    }
};
```

## 221. 最大正方形

[221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)

`对于在矩阵内搜索正方形或长方形的题型,一种常见的做法是定义一个二维 dp 数组,其中dp[i][j] 表示满足题目条件的、以 (i, j) 为右下角的正方形或者长方形的属性。对于本题,则表示以 (i, j) 为右下角的全由 1 构成的最大正方形面积。如果当前位置是 0,那么 dp[i][j] 即为 0;如果当前位置是 1,我们假设 dp[i][j] = k 2 ,其充分条件为 dp[i-1][j-1]、dp[i][j-1] 和 dp[i-1][j] 的值必须都不小于 (k − 1) 2 ,否则 (i, j) 位置不可以构成一个边长为 k 的正方形。同理,如果这三个值中的的最小值为 k − 1,则 (i, j) 位置一定且最大可以构成一个边长为 k 的正方形。`

![image-20210130205321037](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20210130205321037.png)

```cpp
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if(matrix.empty()||matrix[0].empty()){
            return 0;
        }
        int n = matrix.size();
        int m = matrix[0].size();
        int mmax = 0;
        vector<vector<int>>dp(n + 1, vector<int>(m + 1, 0));
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= m; j++) {
                if(matrix[i - 1][j - 1] == '1') {
                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;
                }
                mmax = max(mmax, dp[i][j]);
            }
        }
        return mmax * mmax;
    }
};
```

## 279. 完全平方数

`对于分割类型题,动态规划的状态转移方程通常并不依赖相邻的位置,而是依赖于满足分割条件的位置。我们定义一个一维矩阵 dp,其中 dp[i] 表示数字 i 最少可以由几个完全平方数相加
构成。在本题中,位置 i 只依赖 i - k 2 的位置,如 i - 1、i - 4、i - 9 等等,才能满足完全平方分割的条件。因此 dp[i] 可以取的最小值即为 1 + min(dp[i-1], dp[i-4], dp[i-9] · · · )。`

[279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

```cpp
class Solution {
public:
    int numSquares(int n) {
        vector<int>dp(n + 1, INT_MAX);
        dp[0] = 0;
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j * j <= i; j++) {
                dp[i] = min(dp[i], dp[i - j * j] + 1);
            }
        }
        return dp[n];
    }
};
```

## 91. 解码方法

[91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)

```cpp
class Solution {
public:
    int numDecodings(string s) {
        if(s[0] == '0') return 0;
        vector<int>dp(s.size() + 1);
        dp[0] = dp[1] = 1;
        for(int i = 2; i <= s.length(); i++) {
            //如果该位不为'0'，说明该位单独成字母合法
            if(s[i - 1] != '0') {
                dp[i] += dp[i - 1];
            }
            //如果后两位能组成"1x"（x为任意数字）或者"2x"（x小于7），说明最后两位组成字母合法
            if((s[i - 2] == '1') || (s[i - 2] == '2' && s[i - 1] <= '6')) {
                dp[i] += dp[i - 2];
            }
        }
        return dp[s.length()];
    }
};
```

## 139. 单词拆分

[139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

先把每个单词放在一个unordered_set中以便于切出的单词便于查找

然后每次substr出最大单词之内长度的字符串进行查找为标记为true

```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        vector<bool>dp(s.size() + 1, false);
        unordered_set<string>m(wordDict.begin(), wordDict.end());
        dp[0] = true;
        int mmax = 0;
        for(int i = 0; i < wordDict.size(); i++) {
            mmax = max(mmax, (int)wordDict[i].length());
        }
        for(int i = 1; i <= s.size(); i++) {
            for(int j = max(i - mmax, 0); j < i; j++) {
                if(dp[j] && m.find(s.substr(j, i - j)) != m.end()) {//dp[j]判断每次i前面的字母都能用
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.size()];
    }
};
```

## 300. 最长递增子序列

[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

![image-20210213205237762](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20210213205237762.png)

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        vector<int>f(n, 1);
        for(int i = 1; i < n; i++) {
            for(int j = 0; j < i; j++) {
                if(nums[i] > nums[j])f[i] = max(f[i], f[j] + 1);
            }
        }
        int mmax = 0;
        for(int i = 0; i < n; i++) {
            mmax = max(mmax, f[i]);
        }
        return mmax;
    }
};
```

## 1143. 最长公共子序列

![image-20210212211751676](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20210212211751676.png)

[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n = text1.size();
        int m = text2.size();
        vector<vector<int>>dp(n + 1, vector<int>(m + 1, 0));
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= m; j++) {
                if(text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[n][m];
    }
};
```

## 背包问题

​		背包问题是一中组合优化的NP完全问题：有N个物品和容量为W的背包，每个物品都有自己体积w和价值v，求拿哪些物品可以使得背包所装下物品总价值最大。如果限定没中物品只能选择0个或1个，则问题称为为0-1问题；如果不想定物品的数量，则问题称为无界背包问题或完全背包问题。

​		我们可以用动态规划来解决背包问题。以0-1背包问题为例。我们可以定义一个二维数组dp存储最大价值，其中`dp[i][j]`表示前i件物品体积不超过j的情况下达到的最大价值。