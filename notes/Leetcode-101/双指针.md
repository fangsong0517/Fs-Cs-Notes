# 双指针

双指针主要用于遍历数组,两个指针指向不同的元素,从而协同完成任务。也可以延伸到多个数组的多个指针。若两个指针指向同一数组,遍历方向相同且不会相交,则也称为滑动窗口(两个指针包围的区域即为当前的窗口),经常用于区间搜索。若两个指针指向同一数组,但是遍历方向相反,则可以用来进行搜索,待搜索的数组往往是排好序的。对于 C++ 语言,指针还可以玩出很多新的花样。一些常见的关于指针的操作如下。

## 指针与常量

```cpp
int x;
int *p1 = &x;// 指针可以被修改,值也可以被修改
const int * p2 = &x;// 指针可以被修改,值不可以被修改(const int)
int * const p3 = &x;int * const p3 = &x; // 指针不可以被修改(* const),值可以被修改
const int * const p4 = &x;// 指针不可以被修改,值也不可以被修改
```

## 指针函数与函数指针

```cpp
// addition是指针类型，一个返回类型是指针的函数
int *addition(int a, int b) {
    int * sum = new int(a + b);
    return sum;
}

int subtraction(int a, int b) {
    return a - b;
}

int operation(int x, int y, int (*func)(int , int )) {
    return (*func)(x, y);
}

//minus是函数指针，指向函数的指针
int (*minus)(int, int) = subtraction;

int *m = addition(1, 2);
int n = operation(3, *m, minus);
```

## [167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

在一个增序的整数数组里找到两个数,使它们的和为给定值。已知有且只有一对解。

如果两个指针指向元素的和等于给定值,那么它们就是我们要的结果。如果两个指针指向元素的和小于给定值,我们把左边的指针右移一位,使得当前的和增加一点。如果两个指针指向元素的和大于给定值,我们把右边的指针左移一位,使得当前的和减少一点。

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        vector<int>index;
        int l = 0, r = numbers.size() - 1;
        while(l < r) {
            if(numbers[l] + numbers[r] == target) {
                index.push_back(l + 1);
                index.push_back(r + 1);
                break;
            } else if(numbers[l] + numbers[r] > target) {
                r --;
            } else if(numbers[l] + numbers[r] < target) {
                l ++;
            }
        }
        return index;
    }
};
```

## [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

给你两个有序整数数组 *nums1* 和 *nums2*，请你将 *nums2* 合并到 *nums1* 中*，*使 *nums1* 成为一个有序数组。

**第一种写法，**借助第三个nums3解决此题：

```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        vector<int>nums3;
        int i = 0, j = 0;
        while(i < m && j < n) {
            if(nums1[i] <= nums2[j]) {
                nums3.push_back(nums1[i++]);
            } else {
                nums3.push_back(nums2[j++]);
            }
        }
        while(i < m) {
            nums3.push_back(nums1[i++]);
        }
        while(j < n) {
            nums3.push_back(nums2[j++]);
        }
        nums1.clear();
        for(auto i : nums3) {
            nums1.push_back(i);
        }
        return;
    }
};
```

**第二种写法**：

不用开辟额外的空间

一个指针从合并后的长度前一位开始往前填充，填充到nums1中，见代码

```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int pos = m-- + n-- -1;
        while(n >= 0 && m >= 0) {
            nums1[pos--] = nums1[m] <= nums2[n] ? nums2[n--] : nums1[m--]; 
        }
        while(n >= 0) {
            nums1[pos--] = nums2[n--];
        }
        return;
    }
};
```

