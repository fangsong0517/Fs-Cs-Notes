# 贪心

#### [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

```cpp
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int i = 0, j = 0;
        while(i < g.size()&& j < s.size()) {
            if(g[i] <= s[j]) {//一直控制g[i] <= s[j], 同时往后走
                i++;
            }
            j++;//如果g[i] > s[j],j也得往后走啊
        }
        return i;
    }
};
```

#### [135. 分发糖果](https://leetcode-cn.com/problems/candy/)

一群孩子站成一排,每一个孩子有自己的评分。现在需要给这些孩子发糖果,规则是如果一个孩子的评分比自己身旁的一个孩子要高,那么这个孩子就必须得到比身旁孩子更多的糖果;所有孩子至少要有一个糖果。求解最少需要多少个糖果。

```html
Input: [1,0,2]
Output: 5
```

在这个样例中,最少的糖果分法是 [2,1,2]。

==思路：==

我们只要两次遍历即可：把所有孩子糖果都初始化为1；先从左往右遍历一遍，如果右边的大于左边的，那么有右边的更新为左边的+1，再从右往左遍历一遍,如果左边孩子的评分比右边的高,且左边孩子当前的糖果数不大于右边孩子的糖果数,则左边孩子的糖果数更新为右边孩子的糖果数加 1

```cpp
class Solution {
public:
    int candy(vector<int>& r) {
        int n = r.size();
        vector<int>ret(n, 1);
        for(int i = 1; i < n; i++) {
            if(r[i - 1] < r[i]) {
                ret[i] = ret[i - 1] + 1;//因为刚开始ret都一样所以不判断糖果数
            }
        }
        for(int i = n - 1; i > 0; i--) {
            if(r[i - 1] > r[i]) {
                //ret[i - 1] = max(ret[i - 1], ret[i] + 1);
            	if(ret[i - 1] <= ret[i]) {//因为ret有可能不相同糖果数，所以相同的时候也得加上
                    ret[i - 1] = ret[i] + 1;
                }
            }
        }
        return accumulate(ret.begin(), ret.end(), 0);// std::accumulate 可以很方便地求和
    }
};
```

#### [435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

给定多个区间,计算让这些区间互不重叠所需要移除区间的最少个数。起止相连不算重叠。

```html
Input: [[1,2], [2,4], [1,3]]
Output: 1
```

在这个样例中,我们可以移除区间 [1,3],使得剩余的区间 [[1,2], [2,4]] 互不重叠。

==思路：==

我们应按照结尾的值进行从小到大排序，每个结尾最小的与前一个选择的区间不重叠。

在样例中,排序后的数组为 [[1,2], [1,3], [2,4]]，首先初始化为区间[1,2];由于 [1,3] 与 [1,2] 相交,我们跳过该区间;由于 [2,4] 与 [1,2] 不相交,我们将其保留。因此最终保留的区间为 [[1,2], [2,4]]。

**注意** 需要根据实际情况判断按区间开头排序还是按区间结尾排序。

```cpp
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& inter) {
        int n = inter.size();
        if(n == 0) return 0;
        int sum = 1;//有多少没有被删除的
        sort(inter.begin(), inter.end(), [](auto a, auto b) {
            return a[1] < b[1];
        });
        int end = inter[0][1];
        for(int i = 1; i < n; i++) {
            if(end > inter[i][0]) {//存在重叠的时候
                continue;
            }
            end = inter[i][1];
            sum++;
        }
        return n - sum;
    }
};
```

#### [605. 种花问题](https://leetcode-cn.com/problems/can-place-flowers/)

种花，相邻不能种，0能种，1是已种，求还能中种下吗？

```html
输入: flowerbed = [1,0,0,0,1], n = 1
输出: True
```

==思路：==

为了判断前后可能种的情况，我们应该在前面加上一个0，在最后加上0和1，例如10001变为01000101，只要计算有多少个连续的0即可求出是否能种下多少个，最后判断能否种下！

```cpp
class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        int w = flowerbed.size();
        int t = 0;
        int sum = 0;
        vector<int>f;
        f.push_back(0);
        // 0 1 0 0 0 1 0 1
        for(int i = 0; i < w; i++) {
            f.push_back(flowerbed[i]);
        }
        f.push_back(0);
        f.push_back(1);
        for(int i = 0; i < w + 3; i++) {//因为添加了3个元素，所以w + 3
            if(f[i] == 0) {//求连着的0的个数
                t++;
            } else {
                if(t != 0)sum += (t / 2) - (t & 1 ? 0 : 1);//当不为0的时候，求出了多少个0，奇数/2，偶数/2-1//手动画一下
                t = 0;
            }
        }
        return sum >= n;
    }
};
```

