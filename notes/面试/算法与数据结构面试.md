# 算法与数据结构面试

## 1. 请列举出你所知道的所有排序算法，并且分析他们的时间复杂度

![image-20210220203453015](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20210220203453015.png)

==插入：==有排序区和未排序区，未排序区每次都将一个元素插入到排序区，例如升序，将排序区遍历小的放前面大的当后面，时间复杂度最优的是有序的O(N)时间复杂度，最坏的情况是逆序的O(N^2)，平均一半小一半大与最坏一样O(N ^ 2).

==冒泡：==有排序区和未排序区，从头到尾遍历未排序区，比较相邻元素，每一次都把最大的放在最后面，最优有序O(N)，最坏逆序时间复杂度O(N ^ 2)，和插入排序一样平均也是O(N ^ 2).

==归并：==将数组一分二，二分四，四分八，将已经有序的子序列进行合并，得到完全有序的序列，由于要排序n次，所以要n(logn)时间复杂度

==选择：==从未排序区选择一个最大(小)的元素放在已排序区的末尾，时间复杂度都是O(N ^ 2)，可以用堆进行提升时间复杂度所以这个时候堆排序为O(NlogN)

==快排：==选择一个基准值，升序的话，把小的放在基准值左边，大的都放在右边，每次更换基准值，快排最好的时间复杂度时O(Nlogn)，最坏的时间复杂度是O(N ^ 2)，平均是O(NlogN).快排很普遍的排序。

## 2. 请尽可能多的说出与快速排序相关的知识

选择一个基准值，升序的话，把小的放在基准值左边，大的都放在右边，每次更换基准值，快排最好的时间复杂度时O(NlogN)，最坏的时间复杂度是O(N ^ 2)，平均是O(NlogN).快排很普遍的排序。

为什么最快nlogn，![image-20210220212058507](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20210220212058507.png)

==优化：==STL-sort源码，优化 

1. 选取基准值

   a. 随机选值

   b. 三点取中法(下图取6)

   ​    ![image-20210220212457834](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20210220212457834.png)

2. 递归

   a. 正常是两侧递归，单边递归法，只将右边的进行递归

   ![image-20210220212943303](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20210220212943303.png)

   b. 元素少的时候<= 16的时候，直接插入排序

   c. 快速排序改为堆排序

   ​    递归层数过深时候，STL中sort会将快速排序改为堆排序

![image-20210220213246480](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20210220213246480.png)

==延展：==

快排的时候很像我们的二叉排序树，基准值的选择，一致的

快速选择算法O(N)。

## 3. 如何判断链表有环、求环的长度 以及 找到环的起始点位置？简述算法过程

快慢指针，快慢指针相同则有环

快慢指针，快慢相遇之后，快指针回到头，快慢指针步调一致一起移动，相遇点即为入环点

![image-20210221003652406](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20210221003652406.png)



## 4. 如果现在有 k 个有序数组，如何合并成一个有序数组.

* 合并排序法

* K路归并排序(小顶堆法)

  可以利用小顶堆完成，时间复杂度是O(nklogk)

  一个nk的数组存结果

  创建一个大小为k的最小堆，堆中元素为k个数组中的第一个元素

  重复下列步骤nk次

  取（堆顶元素），存入输出数组中

  用对定远书所在数组的下一个元素将堆顶元素替换掉，如果数组中元素被取光了，将堆顶元素替换为无穷大。

  每次替换堆顶元素后，重新调整堆。

## 5. 请具体说明，为什么归并排序适合处理大数据排序情况

数据太大无法一次性装入内存，归并可以吧数据放在外存存储区, 结果存储区也在外存中。

![image-20210224212318965](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20210224212318965.png)

## 6. 如何快速的输出无序数组中前 k 大的值，请说明你的方法，并分析时间复杂度

1. 直接全部排序（只适用于内存够的情况）

   当数据量较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的方法是将数据全部排序，然后取排序后的数据中的前k个。

2. 快速排序的变形（只使用于内存够的情况）

   这是一个基于快速排序的变形，因为第一种方法中说到将所有元素都排序并不十分高效，只需要找出前k个最大的就行。

   这种方法类似于快速排序，首先选择一个划分元，将比这个划分元大的元素放在他的前面，比划分元小的元素放在它的后面，此时完成了一趟排序。如果此时这个划分元的序号index刚好等于k，那么整个划分元以及它左边的数，刚好就是前k个最大的元素；如果index > k，那么前k大的数据在index的左边，那么继续递归的index - 1个数中进行一趟排序；如果index < k，那么再从划分元的右边继续进行排序，直到index刚好等于k为止。再将前k个数进行排序后，返回TOP k个元素，这种方法避免了对TOPk个元素以外的数据进行排序进行的不必要开销。

   ![image-20210106204146380](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/687474703a2f2f746573742d66616e67736f6e672d696d677375626d69742e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f696d6167652d32303231303130363230343134363338302e706e67)

3. 最小堆法

   这是一种局部淘汰法，先取出前k各数，建立一个最小堆，然后将剩余数字依次与最小堆顶进行比较，如果小于或等于数据，则进行比较下一个；否则删除堆顶元素，并将新的数据插入进堆中，重新调整最小堆。当遍历完数据后，最小堆中的数据即为最大的k个数。

4. 分治法

   将全部数据分为N份，前提是每份的数据都可以督导内存中进行处理，找到每份数据中的最大的K个数。次时剩下NK个数据，如果内存不能容纳Nk个数据，则再进行分治处理，分成M份，找出每份中最大的K个数，如果M * K个数任然不能读入内存中，则基础分治处理。直到剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理。

5. Hash法

   如果和这个数据中有很多重复的数据就可以选择hash法，将重复数去掉。如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间。处理后的数据如果能够读入内存，则可以直接排序；否则可以使用分治法或者最小堆法进行处理数据。

